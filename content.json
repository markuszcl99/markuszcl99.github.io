{"posts":[{"title":"G1垃圾回收器","text":"一、官方文档阅读 原文链接：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html The Garbage-First (G1) garbage collector is a server-style garbage collector, targeted for multiprocessor machines with large memories. It attempts to meet garbage collection (GC) pause time goals with high probability while achieving high throughput. Whole-heap operations, such as global marking, are performed concurrently with the application threads. This prevents interruptions proportional to heap or live-data size. Garbage-First (G1) 垃圾收集器是一种面向服务器端的垃圾收集器，主要针对配备大容量内存的多处理器机器。其设计目标是在实现高吞吐量的同时，以高概率满足用户设定的垃圾收集 (GC) 停顿时间目标。诸如全局标记等全堆操作会与应用程序线程并发执行，从而避免了因堆大小或存活数据量增加而导致停顿时间成比例增长的问题。 The G1 collector achieves high performance and pause time goals through several techniques. G1 收集器通过多种技术实现高性能与可控的停顿时间目标。 The heap is partitioned into a set of equally sized heap regions, each a contiguous range of virtual memory. G1 performs a concurrent global marking phase to determine the liveness of objects throughout the heap. After the marking phase completes, G1 knows which regions are mostly empty. It collects these regions first, which often yields a large amount of free space. This is why this method of garbage collection is called Garbage-First. As the name suggests, G1 concentrates its collection and compaction activity on the areas of the heap that are likely to be full of reclaimable objects, that is, garbage. G1 uses a pause prediction model to meet a user-defined pause time target and selects the number of regions to collect based on the specified pause time target. 堆被划分为一组大小相等的堆区域 (Heap Region)，每个区域是一段连续的虚拟内存地址空间。G1 会执行一个并发的全局标记阶段，以确定整个堆中对象的存活状态。标记阶段完成后，G1 能够识别出哪些区域基本为空。它会优先回收这些区域，通常能快速释放大量空闲空间。这正是该垃圾收集方法得名 “Garbage-First” 的原因。顾名思义，G1 将其回收与整理 (Compaction) 活动的重点放在那些很可能充满可回收对象（即垃圾）的堆区域上。G1 使用一个停顿预测模型来满足用户自定义的停顿时间目标，并根据指定的停顿时间目标选择要回收的区域数量。 G1 copies objects from one or more regions of the heap to a single region on the heap, and in the process both compacts and frees up memory. This evacuation is performed in parallel on multiprocessors to decrease pause times and increase throughput. Thus, with each garbage collection, G1 continuously works to reduce fragmentation. This is beyond the capability of both of the previous methods. CMS (Concurrent Mark Sweep) garbage collection does not do compaction. Parallel compaction performs only whole-heap compaction, which results in considerable pause times. G1 通过将对象从一个或多个堆区域复制（疏散）到堆上的单个区域，在此过程中同时完成内存整理与释放。该疏散过程在多处理器上并行执行，旨在降低停顿时间并提高吞吐量。因此，每次垃圾收集时，G1 都在持续工作以减少内存碎片。这是之前两种方法（CMS 和 Parallel Compaction）所不具备的能力：CMS (Concurrent Mark Sweep) 垃圾收集不进行内存整理；而 Parallel Compaction 仅执行全堆整理，这会导致相当长的停顿时间。 It is important to note that G1 is not a real-time collector. It meets the set pause time target with high probability but not absolute certainty. Based on data from previous collections, G1 estimates how many regions can be collected within the target time. Thus, the collector has a reasonably accurate model of the cost of collecting the regions, and it uses this model to determine which and how many regions to collect while staying within the pause time target. 需要重点指出的是，G1 不是 实时收集器。它能以高概率满足设定的停顿时间目标，但无法提供绝对确定性保证。G1 基于以往收集周期的数据，估算在目标时间内可以回收多少区域。因此，收集器拥有一个相对准确的、关于回收区域成本的模型，并利用此模型在满足停顿时间目标的前提下，决定回收哪些区域以及回收多少区域。 The first focus of G1 is to provide a solution for users running applications that require large heaps with limited GC latency. This means heap sizes of around 6 GB or larger, and a stable and predictable pause time below 0.5 seconds. G1 的首要定位是为需要大堆内存同时又对 GC 延迟敏感的应用场景提供解决方案。这通常意味着堆大小约为 6GB 或更大，且要求稳定、可预测的停顿时间低于 0.5 秒。 Applications running today with either the CMS or the with parallel compaction would benefit from switching to G1 if the application has one or more of the following traits.More than 50% of the Java heap is occupied with live data.The rate of object allocation rate or promotion varies significantly.The application is experiencing undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second). 对于当前正在使用 CMS 或 Parallel Compaction 的应用，如果具备以下一个或多个特征，切换至 G1 可能会带来收益： 超过 50% 的 Java 堆被存活数据占用。 对象分配速率或晋升（Promotion）速率波动显著。 应用正经历不期望的长时间垃圾收集或整理停顿（超过 0.5 到 1 秒）。 G1 is planned as the long-term replacement for the Concurrent Mark-Sweep Collector (CMS). Comparing G1 with CMS reveals differences that make G1 a better solution. One difference is that G1 is a compacting collector. Also, G1 offers more predictable garbage collection pauses than the CMS collector, and allows users to specify desired pause targets. G1 被规划为 CMS 收集器的长期替代方案。与 CMS 相比，G1 的优势在于：首先，G1 是一个整理收集器；其次，G1 能提供比 CMS 更可预测的垃圾收集停顿，并允许用户指定期望的停顿目标。 As with CMS, G1 is designed for applications that require shorter GC pauses. 与 CMS 一样，G1 专为需要较短 GC 停顿的应用而设计。 G1 divides the heap into fixed-sized regions (the gray boxes) as in Figure 9-1, “Heap Division by G1”. G1 将堆划分为固定大小的区域（即灰色方块所示区域），如图所示。 G1 is generational in a logical sense. A set of empty regions is designated as the logical young generation. In the figure, the young generation is light blue. Allocations are done out of that logical young generation, and when the young generation is full, that set of regions is garbage collected (a young collection). In some cases, regions outside the set of young regions (old regions in dark blue) can be garbage collected at the same time. This is referred to as a mixed collection. In the figure, the regions being collected are marked by red boxes. The figure illustrates a mixed collection because both young regions and old regions are being collected. The garbage collection is a compacting collection that copies live objects to selected, initially empty regions. Based on the age of a surviving object, the object can be copied to a survivor region (marked by “S”) or to an old region (not specifically shown). The regions marked by “H” contain humongous objects that are larger than half a region and are treated specially; see the section Humongous Objects and Humongous Allocations in Garbage-First Garbage Collector.G1 在逻辑意义上是分代的。一组空区域被指定为逻辑上的年轻代（图中为浅蓝色区域）。对象分配在此逻辑年轻代中进行，当年轻代填满时，会触发针对这组区域的垃圾收集（即 Young Collection，年轻代收集）。在某些情况下，年轻代区域之外的区域（老年代区域，图中为深蓝色）也可能与年轻代一同被回收，这被称为 Mixed Collection（混合收集）。图中，正在被收集的区域用红色方框标出。该图展示的即为一次混合收集，因为同时回收了年轻代和老年代区域。垃圾收集过程是一个整理式收集，会将存活对象复制到预先选定的、初始为空的区域。根据存活对象的年龄，对象可能被复制到幸存者区域（标记为“S”）或老年代区域（图中未专门标出）。标记为“H”的区域包含 Humongous Objects（巨型对象），这些对象大小超过半个区域，会被特殊处理（详见《Garbage-First 垃圾收集器》章节中关于 Humongous Objects 和 Humongous Allocations 的部分）。 1.1 Allocation (Evacuation) Failure - 分配（疏散）失败「发生该场景时非常危险，通常这时应用服务会产生不可用的情况」As with CMS, the G1 collector runs parts of its collection while the application continues to run and there is a risk that the application will allocate objects faster than the garbage collector can recover free space. See the section Concurrent Mode Failure in Concurrent Mark Sweep (CMS) Collector for the analogous CMS behavior. In G1, the failure (exhaustion of the Java heap) occurs while G1 is copying live data out of one region (evacuating) into another region. The copying is done to compact the live data. If a free (empty) region cannot be found during the evacuation of a region being garbage collected, then an allocation failure occurs (because there is no space to allocate the live objects from the region being evacuated) and a stop-the-world (STW) full collection is done. 与 CMS 类似，G1 收集器在应用持续运行的同时执行部分收集工作，因此存在应用分配对象的速度快于垃圾收集器回收空闲空间速度的风险。在 G1 中，当 G1 将存活数据从一个区域复制（疏散）到另一个区域以进行内存整理时，如果无法为待疏散区域中的存活对象找到空闲（空）区域进行安置，就会发生分配失败，进而触发一次 Stop-The-World (STW) 的全堆收集。 1.2 Floating GarbageObjects can die during a G1 collection and not be collected. G1 uses a technique called snapshot-at-the-beginning (SATB) to guarantee that all live objects are found by the garbage collector. SATB states that any object that is live at the start of the concurrent marking (a marking over the entire heap) is considered live for the purpose of the collection. SATB allows floating garbage in a way analogous to that of a CMS incremental update. 对象可能在一次 G1 收集周期内死亡但未被回收。G1 使用一种称为 Snapshot-At-The-Beginning (SATB) 的技术来确保垃圾收集器能找到所有存活对象。SATB 机制规定，在并发标记（对整个堆的标记）开始时存活的任何对象「写前屏障会将并发标记时被切断引用的对象，重新标记为存活，这些可能是浮动垃圾，待后续 Mixed GC 回收」，在该次收集中都将被视为存活。SATB 允许存在浮动垃圾，其原理与 CMS 的增量更新 (Incremental Update) 机制类似。 1.3 PausesG1 pauses the application to copy live objects to new regions. These pauses can either be young collection pauses where only young regions are collected or mixed collection pauses where young and old regions are evacuated. As with CMS there is a final marking or remark pause to complete the marking while the application is stopped. Whereas CMS also had an initial marking pause, G1 does the initial marking work as part of an evacuation pause. G1 has a cleanup phase at the end of a collection which is partly STW and partly concurrent. The STW part of the cleanup phase identifies empty regions and determines old regions that are candidates for the next collection. G1 会暂停应用以将存活对象复制到新区域。这些停顿可以是年轻代收集停顿（仅收集年轻代区域），也可以是混合收集停顿（同时疏散年轻代和老年代区域）。与 CMS 一样，存在一个最终标记（或重标记）停顿，在应用停止时完成标记。CMS 有一个初始标记停顿，而 G1 将初始标记工作作为一次疏散停顿的一部分来完成。G1 在收集结束时有一个清理阶段，该阶段部分是 STW 的，部分是并发的。清理阶段的 STW 部分负责识别空区域，并确定可作为下一次收集候选的老年代区域。 1.4 Card Tables and Concurrent Phases - 卡表与并发阶段If a garbage collector does not collect the entire heap (an incremental collection), the garbage collector needs to know where there are pointers from the uncollected part of the heap into the part of the heap that is being collected. This is typically for a generational garbage collector in which the uncollected part of the heap is usually the old generation, and the collected part of the heap is the young generation. The data structure for keeping this information (old generation pointers to young generation objects), is a remembered set. A card table is a particular type of remembered set. Java HotSpot VM uses an array of bytes as a card table. Each byte is referred to as a card. A card corresponds to a range of addresses in the heap. Dirtying a card means changing the value of the byte to a dirty value; a dirty value might contain a new pointer from the old generation to the young generation in the address range covered by the card. 如果垃圾收集器不收集整个堆（即增量收集），它需要知道堆中未被收集部分（通常是老年代）有哪些指针指向正在被收集的部分（通常是年轻代）。用于保存此类信息（老年代指向年轻代对象的指针）的数据结构称为 记忆集。卡表 是一种特殊类型的记忆集。Java HotSpot VM 使用一个字节数组作为卡表，每个字节称为一张卡。一张卡对应堆中的一段地址范围。弄脏一张卡意味着将该字节的值改为一个“脏”值；一个脏值可能表示在该卡覆盖的地址范围内存在一个从老年代指向年轻代的新指针。 Processing a card means looking at the card to see if there is an old generation to young generation pointer and perhaps doing something with that information such as transferring it to another data structure. 处理一张卡意味着检查该卡以判断是否存在老年代到年轻代的指针，并可能据此信息执行某些操作，例如将其转移到另一个数据结构。 G1 has concurrent marking phase which marks live objects found from the application. The concurrent marking extends from the end of a evacuation pause (where the initial marking work is done) to the remark. The concurrent cleanup phase adds regions emptied by the collection to the list of free regions and clears the remembered sets of those regions. In addition, a concurrent refinement thread runs as needed to process card table entries that have been dirtied by application writes and which may have cross region references. G1 有一个并发标记阶段，负责标记从应用中发现的存活对象。该并发标记阶段从一次疏散停顿（初始标记工作在此完成）结束开始，持续到重标记停顿之前。并发清理阶段 将收集后清空的区域添加到空闲区域列表，并清除这些区域的记忆集。此外，一个并发 refinement 线程会根据需要运行，以处理被应用写操作弄脏的、可能含有跨区域引用的卡表条目。 1.5 Starting a Concurrent Collection Cycle - 启动并发收集周期As mentioned previously, both young and old regions are garbage collected in a mixed collection. To collect old regions, G1 does a complete marking of the live objects in the heap. Such a marking is done by a concurrent marking phase. A concurrent marking phase is started when the occupancy of the entire Java heap reaches the value of the parameter InitiatingHeapOccupancyPercent. Set the value of this parameter with the command-line option -XX:InitiatingHeapOccupancyPercent=. The default value of InitiatingHeapOccupancyPercent is 45. 如前所述，老年代和年轻代区域在混合收集中一同被回收。为收集老年代区域，G1 需要对堆中的存活对象进行一次完整的标记。此类标记由并发标记阶段完成。当整个 Java 堆的使用率达到参数 InitiatingHeapOccupancyPercent 的值时，将启动一个并发标记周期。可使用命令行选项 -XX:InitiatingHeapOccupancyPercent= 设置此参数的值，其默认值为 45。 1.6 Pause Time Goal - 停顿时间目标Set a pause time goal for G1 with the flag MaxGCPauseMillis. G1 uses a prediction model to decide how much garbage collection work can be done within that target pause time. At the end of a collection, G1 chooses the regions to be collected in the next collection (the collection set). The collection set will contain young regions (the sum of whose sizes determines the size of the logical young generation). It is partly through the selection of the number of young regions in the collection set that G1 exerts control over the length of the GC pauses. You can specify the size of the young generation on the command line as with the other garbage collectors, but doing so may hamper the ability of G1 to attain the target pause time. In addition to the pause time goal, you can specify the length of the time period during which the pause can occur. You can specify the minimum mutator usage with this time span (GCPauseIntervalMillis) along with the pause time goal. The default value for MaxGCPauseMillis is 200 milliseconds. The default value for GCPauseIntervalMillis (0) is the equivalent of no requirement on the time span. 使用 -XX:MaxGCPauseMillis 标志为 G1 设置停顿时间目标。G1 使用预测模型来决定在目标停顿时间内可以完成多少垃圾收集工作。在一次收集结束时，G1 会选择下一次收集要回收的区域（收集集）。收集集将包含年轻代区域（其大小总和决定了逻辑年轻代的尺寸）。G1 部分通过控制收集集中年轻代区域的数量来调控 GC 停顿的长度。虽然可以像其他垃圾收集器一样在命令行指定年轻代的大小，但这样做可能会妨碍 G1 实现目标停顿时间的能力。除了停顿时间目标，您还可以指定停顿发生的时间窗口。您可以使用 -XX:GCPauseIntervalMillis 参数（与此时间跨度一同）以及停顿时间目标，来指定在此时间间隔内应用线程（Mutator）的最小使用率。MaxGCPauseMillis 的默认值是 200 毫秒。GCPauseIntervalMillis 的默认值是 0，这相当于不对时间窗口做要求。 二、G1 垃圾收集周期整理2.1 垃圾回收流程图 2.2 垃圾回收分阶段交互图 2.3 Card Table &amp; Remembered Set2.3.1 Card Table和Remembered Set是G1实现高效部分回收的核心Card Table是”探测器”： 粗粒度标记哪些地方”可能”有跨区域引用 写屏障开销小，快速标记 为Refinement线程提供工作线索 Remembered Set是”精确记录”： 每个Region都有，记录谁引用了自己 细粒度，精确到具体位置 使GC可以精确扫描，避免全堆遍历 它们共同解决了分代/分区GC的核心难题：如何高效追踪跨区域引用。 Card Table提供快速探测，RSet提供精确记录，Refinement线程在中间桥接。这个三层架构让G1在保持高吞吐量的同时，实现了精确的部分回收和可控的停顿时间。 2.4 RSet refinement 线程介绍Refinement线程（并发Refinement Thread）是G1中处理跨区域引用的核心维护线程，专门负责”精炼”卡表（Card Table），保持记忆集（RSet）的准确性和时效性。 在G1中，每个区域都有自己的记忆集（RSet），记录其他区域指向本区域的指针。例如：Region A（老年代）中的对象引用Region B（年轻代）中的对象。这种引用关系需要被准确记录，以便在收集Region B时知道要从Region A扫描哪些对象 Refinement线程是G1实现高效跨区域引用追踪的关键组件： 做什么：异步处理脏卡，精确识别跨区域引用，更新目标区域的RSet 为什么：避免在应用线程中同步更新RSet，减少写屏障开销 何时工作：持续在后台运行，也在GC停顿期间辅助处理核心价值： 写操作几乎无开销：应用线程只标记脏卡 精确RSet：实现精确的跨区域引用追踪 减少GC扫描范围：在收集区域时只扫描相关部分 自适应：根据负载动态调整工作强度（白/绿/黄/红） 简单来说，Refinement线程让G1在保持RSet准确性的同时，避免了写屏障对应用性能的影响，是实现高吞吐量和低停顿平衡的关键技术之一。 三、G1 垃圾回收日志介绍123456789101112131415161718192021222324252627282930313233342025-12-05T11:45:52.802+0800: 1282286.147: [GC pause (G1 Evacuation Pause) (young) (initial-mark) (to-space exhausted), 69.9688781 secs] [Parallel Time: 56494.8 ms, GC Workers: 8] [GC Worker Start (ms): Min: 1282286147.9, Avg: 1282286148.0, Max: 1282286148.0, Diff: 0.1] [Ext Root Scanning (ms): Min: 1.2, Avg: 2.1, Max: 4.0, Diff: 2.8, Sum: 16.9] [Update RS (ms): Min: 2127.1, Avg: 2127.4, Max: 2127.8, Diff: 0.7, Sum: 17018.8] [Processed Buffers: Min: 2751, Avg: 2937.5, Max: 3290, Diff: 539, Sum: 23500] [Scan RS (ms): Min: 20.1, Avg: 20.6, Max: 21.2, Diff: 1.1, Sum: 164.9] [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Object Copy (ms): Min: 53994.6, Avg: 54001.8, Max: 54040.0, Diff: 45.5, Sum: 432014.6] [Termination (ms): Min: 2.6, Avg: 40.8, Max: 46.3, Diff: 43.7, Sum: 326.7] [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 8] [GC Worker Other (ms): Min: 301.8, Avg: 301.8, Max: 301.9, Diff: 0.1, Sum: 2414.8] [GC Worker Total (ms): Min: 56494.5, Avg: 56494.6, Max: 56494.6, Diff: 0.1, Sum: 451956.6] [GC Worker End (ms): Min: 1282342642.5, Avg: 1282342642.5, Max: 1282342642.5, Diff: 0.0] [Code Root Fixup: 26.0 ms] [Code Root Purge: 0.0 ms] [Clear CT: 3.0 ms] [Other: 13445.0 ms] [Evacuation Failure: 11416.9 ms] [Choose CSet: 0.0 ms] [Ref Proc: 9.1 ms] [Ref Enq: 53.2 ms] [Redirty Cards: 1782.0 ms] [Humongous Register: 0.1 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 19.5 ms] [Eden: 3752.0M(3752.0M)-&gt;0.0B(3824.0M) Survivors: 544.0M-&gt;472.0M Heap: 13.3G(14.0G)-&gt;13.9G(14.0G)]Heap after GC invocations=35479 (full 0): garbage-first heap total 14680064K, used 14546406K [0x0000000440000000, 0x0000000440803800, 0x00000007c0000000) region size 8192K, 59 young (483328K), 59 survivors (483328K) Metaspace used 89729K, capacity 92576K, committed 98432K, reserved 1136640K class space used 9844K, capacity 10432K, committed 11136K, reserved 1048576K} [Times: user=75.36 sys=21.78, real=69.97 secs] 这是一段非常严重的GC日志，GC停顿接近70秒！ 由日志可知此阶段出于 YoungGC 阶段，同时启动对象疏散，但失败了（当前机器无可分配的内存空间），因此触发了G1的降级机制（STW 全堆垃圾回收），导致性能急剧下降。 3.1 各阶段耗时分析3.1.1 并行阶段8个GC工作线程并行工作，但仍耗时56.5秒，说明堆非常大或问题严重。关键子阶段： Ext Root Scanning (2.1ms)：扫描根对象，正常 Update RS (2127.4ms = 2.1秒！)：更新RSet时间异常长 Processed Buffers: 23500：处理了23500个缓冲区，说明RSet非常大 Scan RS (20.6ms)：扫描RSet，相对正常 Object Copy (54001.8ms = 54秒！)：对象复制耗时占绝大部分 这是疏散的核心操作，耗时54秒说明： 存活对象极多 堆碎片化严重 可能触发了退化行为 3.1.2 其他阶段123[Evacuation Failure: 11416.9 ms] # 疏散失败处理[Redirty Cards: 1782.0 ms] # 重新标记卡表[Free CSet: 19.5 ms] # 释放回收集","link":"/2025/12/07/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/11/29/hello-world/"},{"title":"java从1到25版本的变化","text":"Java 1 到 25 版本变化（2025版）第一部分：Java 1 - 8Java 1.0主要语言特性引入 语法：逻辑、循环、封装、派生（继承、实现）、多态 类型：类、接口、抽象类、数组、原生数据类型（byte、int等） 类型：Boolean、Integer以及 String等 数据结构：Vector、Stack、Dictionary以及 Enumeration等 类加载：Class、ClassLoader等 虚拟机：Compiler、System 异常：Throwable、Error以及 Exception等 并发：Thread 图形化：AWT 浏览器插件：Applet 科学：Math IO：File、InputStream、OutputStream 网络：URL、Socket 安全（Security）：SecurityManager 主要 API特性引入 字节码 垃圾回收器（GC） 安全沙箱 Java Native Interface（JNI） 工具（Tools） Java编译器 JavaDoc主要 JVM特性引入 (无明确列出)Java 1.1主要语言变化引入 内部类支持Unicode支持反射：仅支持内省（Introspection）主要 API变化引入 层次关系型数据库- Java Database Connectivity(JDBC)国际化（Internationalization）内省（Introspection）- Java Beans远程方法调用- Remote Method Invocation（RMI）对象序列化（Serialization）图形化：AWT API重构浏览器插件：AppletIO：Reader、Writer和 PrintStream等网络：可扩展 Socket和 ServerSocekt等安全（Security）主要 JVM变化引入 JIT编译器（Windows平台）性能提升基于汇编重写 Win32和 Solaris/SPARC平台 JVM部分实现Mac支持非连续型 Heap使得同步方法执行更有效率主要 JVM变化更新 GC释放未使用的 Class对象，并且更高效地使用内存Win32平台 AWT重写JRE JAR压缩合并Java 1.2（A.k.a Java 2）主要语言变化引入 strictfp关键字支持（Java 17开始废弃该关键字）主要 API变化引入 Swing集合（Collections）IDL：IDL（Interface Definition Language）以及 CORBA(Common Object Request Broker Architecture)交互引用（Reference）包版本（Package Versioning）主要 API变化更新 AWT Java 2D支持拖拽（Drag&amp; Drop）支持输入法支持JavaBeans： Applet交互语义, 运行时容器和服务支持, Design Time支持反射（Reflection）：支持细粒度的 Class成员，如 Field、Method、Constructor等JDBC：JDBC 2.0，支持 JDBC-ODBC安全（Security）：基于策略的细粒度访问控制，Certificate接口，X.509 V3实现，以及客户端安全主要 JVM变化引入 全工具支持浏览器插件：允许客户指导Java小程序或JavaBeans组件使用Sun的 JRE运行，而不是使用浏览器 的默认 JREClassLoader扩展机制：Java ClassLoader Extension框架整合版本支持：Java规范和 JVM版本主要 JVM变化更新 JIT编译器支持 Windows和 Solaris平台JAR文件格式扩展Java Native Interface（JNI）Java Profiler Interface(JVMPI)JVM Debugger Interface(JVMDI)性能提升Solaris原生 Thread支持压缩已加载 Class对象快速内存分配和垃圾收集同步方法性能提升RMI性能提升对象序列化性能提升Java 1.3主要语言变化引入 (无明确列出)主要 API变化引入 Java Naming and Directory Interface （JNDI）Java SoundJava Dynamic Proxy主要 API变化更新 远程方法调用（RMI）：可选支持 CORBA对象序列化（Serialization）主要 JVM变化引入 正式引入 Hotspot虚拟机Windows 95平台支持主要 JVM变化更新 JIT编译器支持 Windows和 Solaris平台JAR文件格式扩展Java Native Interface（JNI）工具（Tools）： Java Platform Debugger Architecture （JPDA）, Java Profiler Interface(JVMPI), JVM Debugger Interface(JVMDI)性能提升Solaris原生 Thread支持压缩已加载 Class对象快速内存分配和垃圾收集同步方法性能提升RMI性能提升对象序列化性能提升Java 1.4主要语言变化引入 Java断言- assert关键字正则表达式（Regular Expressions）异常栈跟踪（Stack Trace）：StackTraceElementNew输入/输出（I/O）（NIO）：非阻塞输入/输出（I/O）日志（Logging）XML处理XML解析XSTL处理PreferencesImage输入/输出（I/O）：读、写 JPEG以及 PNG等打印服务（Print Service）主要 API变化引入 网络（Network）安全（Security）： Java Cryptography Extension(JCE)：Java加密扩展, Java Secure Socket Extension （JSSE）：Java安全 Socket扩展, Java Authentication and Authorization Service（JAAS）：Java认证与授权服务用户界面（UI）： AWT 全频独占模式, Headless模式支持, 32位和 64位寻址兼容, Java 2D, SwingJava Beans：⻓期存储JDBC 3.0：事务 Savepoint引入远程方法调用（RMI）：RMI-IIOP对象序列化（Serialization）国际化（Internationalization）： Unicode 3.0支持, Currency类支持数学（Math）：BigInteger方法新增更多计算方法主要 JVM变化引入 Java Web Start支持Endorsed标准覆盖机制主要 JVM变化更新 工具（Tools）： Java Debugger架构（Java Platform Debugger Architecture）, 全速 Debug支持, Hotswap Debug, 对象过滤器, Debug其他 JVM语言, VM终止请求性能优化Java 2D反射（Reflection）HTTP StreamingBigIntengerJava Plugin升级JNI升级Java 5主要语言变化引入 泛型（Generic）for-each语法自动装箱（Boxing）和拆箱（Unboxing）枚举（Enum）变量参数（varargs）静态倒入（ static import ）注解（Annotations）主要 API变化引入 进程（Process）：ProcessBuilder API格式化（Format）：Formatter API并发（Concurrency）：J.U.C并发框架装备（Instrumentation）：Java Agent运行时装备字节码Java Monitoring and Management（JMX）主要 API变化更新 反射（Reflection）：增加对泛型的支持正则表达式（Regular Expressions）：Scanner针对 Stream正则搜索和处理集合（Collections）：泛型、自动装箱/拆箱、for-each支持、并发支持、新数据结构和操作方法线程（Threads）：Java Thread优先级变更、新增线程状态（Thread.State）和 Thread.UncaughtExceptionHandler以及 sleep()支持 0毫秒网络（Network）：网络 API提升安全（Security）： Java Cryptography Extension(JCE）, Java Secure Socket Extension （JSSE）, Java Authentication and Authorization Service（JAAS）, Simple Authentication and Security Layer(SASL）, Java Generic Security Services(Java GSS-API）系统（System）：System.getenv()直接使用 ProcessEnvironment.getenv()实现Java Beans：新增 PropertyChangeEvent子类 IndexedPropertyChangeEventRMI：动态存根类生成、SSL/TLS Socket工厂类、从 inetd/xinetd启动 RMI服务器和后台程序IDL：CORBA、Java IDL以及 Java RMI-IIOP提升JNDI：支持标准 LDAP协议控制，以及多 LDAP名称JDBC：增加 RowSet支持（包括：JdbcRowSet、CachedRowSet、FilteredRowSet、 JoinRowSet以及 WebRowSet）对象序列化（Serialization）：支持枚举类型国际化（Internationalization）： Unicode 4.0支持, Locate国家和地区完善, DecimalFormat解析进度提升数学（Math）：BigInteger方法新增更多计算方法用户界面（UI）： 国际化支持, Java Sound提升, Java 2D：新增 Linux以及 Solaris打印机支持、图像、文字渲染硬件加速（引入 OpenGL）, Image输入/输出（I/O）：BMP以及 WBMP图形处理, AWT提升, Swing提升主要 JVM变化引入 类数据共享（Class Data Sharing）垃圾回收自适应管理（Garbage Collector Ergonomics）服务器级别 JVM自测（Server-Class Machine Detection）线程优先级变更（Thread Priority Changes）严重问题处理（Fatal Error Handling）高进度时间支持（High-Precision Timing Support）部署主要 JVM变化更新 Pack200，高压缩 JAR，用于 Java Web Start工具引入 Java编程的 Java Compiler(javac)实现：com.sun.tools.javac.MainAnnotation Processing Tool（APT）网络（Network）：IPv6对 Windows XP（SP1）和 2003 Server工具（Tools）： Java Virtual Machine Tool Interface(JVMTI), Java Platform Debugger Architecture(JPDA), Java Compiler(javac), JavaDocAMD 64位 Opteron多处理器支持@Override编译期校验Java 6主要语言变化引入 Scripting（脚本）ServiceLoader（SPI）Java编译器（Java Compiler）Web Service（JAX-WS）Java XML Binding（JAXB） 2.0主要 API变化引入 集合（Collections）：新数据结构（普通集合和并发集合）和操作方法主要 API变化更新 并发（Concurrency）：增加 AbstractQueuedLongSynchronizer扩展 state的范围装备（Instrumentation）：支持类重新定义、装备 native方法以及追加 ClassLoader搜索国际化（Internationalization）： ResourceBundle新增 Control提升资源控制, Normalizer支持 Unicode文本标准化, Locales更新输入/输出（I/O）： File提升, NIO新增 epoll支持（前提内核支持）, FileChannel文件锁设置反射（Reflection）：编译器泛型警告网络（Network）： NetworkInterface提升, 默认 CookieManager实现, 轻量级 HTTP Server安全（Security）：安全升级Java Beans：新增@ConstructorPropertiesRMI：MarshalledObject支持泛型JDBC：JDBC 4.0升级对象序列化（Serialization）：ObjectStreamClass新增 lookupAny方法用户界面（UI）： AWT提升, Swing提升主要 JVM变化引入 DTrace支持Java DB工具 JConsole GUI工具主要 JVM变化更新 垃圾回收（Garbage Collection）, 并行垃圾收集器（Parallel Compaction）, 并行标记和清扫（Concurrent Mark Sweep Collector） CMS工具（Tools）： Java Virtual Machine Tool Interface(JVMTI), Java Platform Debugger Architecture(JPDA)性能优化线程同步JIT编译Java 7主要语言变化引入 泛型：Diamond操作符语法自动资源管理：AutoCloseable对象 try-with-resources语句合并多异常处理：catch(X x | Y y){…}动态语言支持： invokedynamic字节码switch语句对 String类型支持整数类型支持二进制申明整数类型支持”_”连接申明主要 API变化引入 编译器（Compiler）：引入 MethodHandle API提升方法执行集合（Collections）： 新数据结构主要 API变化更新 普通并发： LinkedTransferQueue, 算法 TimSort整合并发（Concurrency）：新增 ForkJoinPool、 ThreadLocalRandom和 Phaser装备（Instrumentation）国际化（Internationalization） Unicode 6.0.0、字符集、脚本升级, Currency扩展 ISO 4217货币代码, Locale支持 Category、BCP47、UTR35, 正则表达式支持 Unicode 6.0类加载（Class Loading）：自定义并行 ClassLoading输入/输出（I/O）： NIO 2.0升级反射（Reflection）网络（Network）： URLClassLoader增加 close方法, Sockets Direct Protocol(SDP)提升性能安全（Security）：安全升级Java BeansRemote Method Invocation（RMI）IDL（Interface Definition Language）Java Database Connectivity(JDBC）：JDBC 4.1升级对象序列化（Serialization）用户界面（UI）： AWT提升, Swing提升, Java 2D主要 JVM变化引入 64位压缩指针（Compressed Oops）：-XX:+UseCompressedOops基于零的压缩普通对象指针（Tiered Compilation）JIT Compiler：分层编译垃圾回收（Garbage Collection） Garbage-First Collector（G1）逃逸分析（Escape Analysis）主要 JVM变化更新 垃圾回收（Garbage Collection） Parallel Scavenger garbage collector支持 NUMANUMA性能提升Java 8主要语言变化新增 Lambda表达式方法引用（Method References）默认方法（Default Method）可重复标注：@Repeatable类型注解方法参数反射：-parameters编译参数主要语言变化更新 提升类型推断主要 API变化引入 Compact Profiles：Profiles定制化 API集合Date-Time：JSR 310JavaFX引入集合（Collections）： Stream APIHashMap在键冲突时性能提升并发（Concurrency）： CompletableFuture, ConcurrentHashMap红黑树升级、Lambda语法重构, 新增高性能原子操作类, ForkJoinPool通用 pool, 新增读写锁优化实现 StampedLock脚本（Scripting）：Nashorn替代 Rhino JavaScript引擎，支持 ECMAScript 5.1语言规范国际化（Internationalization）： 支持 Unicode 6.2.0, 新增 ResourceBundle.Control SPI, ResourceBundleControlProviderJava Database Connectivity(JDBC）： JDBC-ODBC桥接移除, JDBC 4.2升级Java Management Extensions(JMX)：支持远程诊断命令用户界面（UI）： AWT提升, Swing提升主要 API变化更新 (无明确列出)主要 JVM变化新增 Metaspace主要 JVM变化更新 垃圾回收（Garbage Collection）输入/输出（I/O）： 减少/jre/lib/charsets.jar文件大小性能提升（Performance） java.lang.String字节数组性能优化工具（Tools） Pack200：动态类型语言, 引入 Java Mission Control 5.3, jjs：JavaScript引擎工具, jdeps：Java类依赖分析, 引入 Java DB 10.10引入 MetaSpace，移除 PermGen新增 Advanced Encryption Standard(AES)第二部分：Java 9 - 11Java 9主要语言变化新增 模块化系统（Module System）： JSR 376新版本定义机制：MAJOR.MINOR.SECURITY.PATCH主要语言变化更新 try-with-resources语法允许变量使用 final修饰diamond语法允许匿名类（如果类型推断的参数类型可表示的话）接口允许定义 private方法@SafeVarargs允许声明在实例 private方法上主要 API变化引入 进程（Process）：JEP 102，全新 API ProcessHandle提供更好的管控操作系统内存（Memory）：JEP 193，VarHandle作为正式 API替代 Unsafe，对变量执行原子和内存屏障 操作日志（Logging）：JEP 264，全新日志 API和服务XML：JEP 268，添加标准的 XML Catalog API栈（Stack）：JEP 259，全新栈跟踪工具，StackWalker替代老的 StackTraceElement体系字符串（String）：String底层存储从 char[]替换为 byte[]集合（Collections）：JEP 269，集合接口提供便利的工厂方法，如，Set.of(…)并发（Concurrency）：JEP 266，CompletableFuture以及其他并发组件提升编译器（Compiler）：JEP 274，提升 MethodHandle通用性以及更好地编译优化注解（Annotation）：JEP 277，@Deprecated注解增加 since和 forRemoval属性，丰富 API淘汰策略线程（Threading）：JEP 285，新增自旋方法 Thread.onSpinWait对象序列化（Serialization）：JEP 290，新增 API ObjectInputFilter过滤 ObjectInputStreamXML：JEP 255，更新 Xerces 2.11.0解析 XMLJava Management Extensions(JMX)：支持远程诊断命令脚本（Scripting）： JEP 236，Nashorn解析器 API引入, JEP 292，实现 ECMAScript 6功能国际化（Internationalization）： JEP 267，支持 Unicode 8.0, JEP 252，JDK 8引入的 XML形式的 Common Locale Data Repository(CLDR)作为默认选项, JEP 226，支持 UTF-8 Properties文件Java Database Connectivity(JDBC）： JDBC-ODBC桥接移除, JDBC 4.2升级用户界面（UI）： JEP 251: Multi-Resolution Images, JEP 253: Prepare JavaFX UI Controls and CSS APIs for Modularization, JEP 256: BeanInfo Annotations, JEP 262: TIFF Image I/O, JEP 263: HiDPI Graphics on Windows and Linux, JEP 272: Platform-Specific Desktop Features, JEP 283: Enable GTK 3 on Linux主要 API变化更新 String压缩：JEP 254: Compact Strings主要 JVM变化新增 垃圾回收（Garbage Collection） 移除组合： 并行标记和清扫（Concurrent Mark Sweep Collector） CMS：JEP 291, DefNew+ CMS, ParNew+ SerialOld, Incremental CMSGarbage-First（G1）： 提升可读性和性能优化, 标记为默认 GC：JEP 248统一 JVM日志：JEP 158:输入/输出（I/O）： 减少/jre/lib/charsets.jar文件大小性能提升（Performance） java.lang.String字节数组性能优化工具（Tools） Java Plug-in标记为不推荐使用，未来版本移除, jshell：JEP 222，增加 Read-Eval-Print Loop, jcmd：JEP 228，增加更多诊断命令, jlink：JEP 282，组装和优化模块以及依赖, 多版本发布 JAR文件：JEP 238移除指定版本 JRE启动移除 HProf Agent：JEP 240编译器控制：JEP 165，通过指令文件控制 JVM编译器Code Cache分段存储：JEP 197对象模型动态链接：JEP 276Java 10主要语言变化新增 本地变量类型推断（Local-Variable Type Inference）主要语言变化更新 (无明确列出)主要 API变化引入 通用：Optional新增方法主要 API变化更新 安全（Security）： JEP 319，默认根证书主要 JVM变化新增 JIT Compiler：JEP 317实验性的 Java编写的 JIT Compiler主要 JVM变化更新 垃圾回收（Garbage Collection） Garbage-First（G1）： 并行 Full GC支持, JEP 304: Garbage Collector Interface内存（Memory）：运行 JVM Heap在用户可选的设备上分配，如：NV-DIMM应用层级的 CDS：JEP 310线程（Threading）：JEP 312 Thread-Local Handshakes工具（Tools） javac：for循环字节码生成优化, javadoc： 支持多样式, 新选项：–overridden-methods, 新内嵌 tag：{@summary…}javah：JEP 313被移除国际化（Internationalization）：增加 Unicode语言 Tag扩展版本发布： JEP 322，基于时间发布版本信息字节码（Byte-code）： 基于嵌套类型访问控制（JEP 181: Nest-Based Access Control）, 新增常量池形式：CONSTANT_Dynamic（JEP 309: Dynamic Class-File Constants）Lambda参数局部变量语句：JEP 323: Local-Variable Syntax for Lambda ParametersJava 11（LTS）主要语言变化新增 [预览] Switch语句优化（JEP 325: Switch Expressions(Preview)）主要语言变化更新 (无明确列出)主要 API变化引入 HTTP：新增 HTTP客户端（JEP 321: HTTP Client(Standard)）通用：Optional国际化（Internationalization）： Unicode 10支持（JEP 327: Unicode 10）安全（Security）： 与 Curve25519和 Curve448的关键协议（JEP 324: Key Agreement with Curve25519 and Curve448）, Chacha20和 Poly1305加密算法（JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms）, TLS 1.3支持（JEP 332: Transport Layer Security(TLS) 1.3）用户界面（UI）： 移除 Java EE和 CORBA模块（JEP 320: Remove the Java EE and CORBA Modules）, java.xml.ws(JAX-WS, SAAJ and Web Services Metadata), java.xml.bind(JAXB), java.activation(JAF), java.xml.ws.annotation(Common Annotations), java.corba(CORBA), java.transaction(JTA)主要 API变化更新 (无明确列出)主要 JVM变化新增 JIT Compiler：JEP 317实验性的 Java编写的 JIT Compiler垃圾回收（Garbage Collection） 无操作 GC（JEP 318: Epsilon: A No-Op Garbage Collector）, 实验性地引入 ZGC（JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)）工具 Java Fight Recorder（JEP 328: Flight Recorder）java命令直接启动单个 Java源文件（JEP 330: Launch Single-File Source-Code Programs）低消耗 JVM Heap Profiling（JEP 331: Low-Overhead Heap Profiling）主要 JVM变化更新 内存（Memory）：运行 JVM Heap在用户可选的设备上分配，如：NV-DIMM应用层级的 CDS：JEP 310输入/输出（I/O）性能提升（Performance）工具（Tools） 不推荐 JavaScript引擎 Nashorn（JEP 335: Deprecate the Nashorn JavaScript Engine）, 不推荐 Pack200工具（JEP 336: Deprecate the Pack200 Tools and API）GUI： 移除 Java Applet, 移除 Java Web Start, 移除 JavaFX指令：提升 Aarch64内联函数（JEP 315: Improve Aarch64 Intrinsics）第三部分：Java 12 - 17Java 12主要语言变化新增 [预览] Switch语句优化更新（JEP 354: Switch Expressions(Preview)）[预览]文件块（JEP 355: Text Blocks(Preview)）主要 API变化引入 (无明确列出)主要 API变化更新 (无明确列出)主要 JVM变化新增 单一 AArch64端口（JEP 340: One AArch64 Port, Not Two）默认 CDS归档（JEP 341: Default CDS Archives）垃圾回收（Garbage Collection） [实验性] Shenandoah GC（JEP 189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)）Microbenchmark套件（JEP 230: Microbenchmark Suite）主要 JVM变化更新 垃圾回收（Garbage Collection） Garbage First（G1） 可中断混合收集（JEP 344: Abortable Mixed Collections for G1）, 返回未提交内存（JEP 346: Promptly Return Unused Committed Memory from G1）Java 13主要语言变化新增 [预览] instanceof语句优化（JEP 305: Pattern Matching for instanceof(Preview)）[预览]文件块更新（JEP 368: Text Blocks(Second Preview)）[预览] Record类型（JEP 359: Records(Preview)）Switch语句优化（JEP 361: Switch Expressions(Standard)）主要 API变化引入 [孵化]外部内存访问 API（JEP 370: Foreign-Memory Access API(Incubator)）主要 API变化更新 网络（Network）：重新实现 Socket API（JEP 353: Reimplement the Legacy Socket API）主要 JVM变化新增 (无明确列出)主要 JVM变化更新 垃圾回收（Garbage Collection） ZGC 返回未提交内存（JEP 351: ZGC: Uncommit Unused Memory）Java 14主要语言变化新增 文本块（JEP 378: Text Blocks）隐藏类（JEP 371: Hidden Classes）[预览] Sealed类（JEP 360: Sealed Classes(Preview)）[预览] instanceof语句优化（JEP 375: Pattern Matching for instanceof(Second Preview)）[预览] Record类型（JEP 384: Records(Second Preview)）主要 API变化引入 (无明确列出)主要 API变化更新 (无明确列出)主要 JVM变化新增 非 volatile内存 ByteBuffer映射（JEP 352: Non-Volatile Mapped Byte Buffers）空指针异常内容辅助（JEP 358: Helpful NullPointerExceptions）垃圾回收（Garbage Collection） ZGC 支持 macOS（JEP 364: ZGC on macOS）, 支持 Windows（JEP 365: ZGC on Windows）, CMS 移除（JEP 363: Remove the Concurrent Mark Sweep(CMS) Garbage Collector）, Garbage First（G1） NUMA架构内存分配（JEP 345: NUMA-Aware Memory Allocation for G1）工具 JFR流（JEP 349: JFR Event Streaming）[孵化]打包工具（JEP 343: Packaging Tool(Incubator)）移除 Pack200（JEP 367: Remove the Pack200 Tools and API）Java 15主要语言变化引入 [孵化]外部内存访问 API（JEP 383: Foreign-Memory Access API(Second Incubator)）主要语言变化更新 网络（Network）：重新实现 Socket API（JEP 353: Reimplement the Legacy Socket API）Remote Method Invocation（RMI）：JEP 385: Deprecate RMI Activation for Removal主要 API变化引入 安全（Security）： JEP 339: Edwards-Curve Digital Signature Algorithm(EdDSA)主要 API变化更新 (无明确列出)主要 JVM变化新增 移除 Solaris和 SPARC JVM实现（JEP 381: Remove the Solaris and SPARC Ports）线程（Threading） 失效和不推荐使用偏向锁（JEP 374: Disable and Deprecate Biased Locking）垃圾回收（Garbage Collection） ZGC 正式发布（JEP 377: ZGC: A Scalable Low-Latency Garbage Collector）, Shenandoah 正式发布（JEP 379: Shenandoah: A Low-Pause-Time Garbage Collector）工具 移除 Nashorn JavaScript引擎（JEP 372: Remove the Nashorn JavaScript Engine）Java 16主要语言变化引入 Record类型正式引入（JEP 395: Records）instanceof语句优化正式引入（JEP 394: Pattern Matching for instanceof）包装类警告（JEP 390: Warnings for Value-Based Classes）模块化（Modular）：JDK内部 API默认强封装（JEP 396: Strongly Encapsulate JDK Internals by Default）[孵化]向量 API（JEP 338: Vector API(Incubator)）[预览] Sealed类（JEP 397: Sealed Classes(Second Preview)）主要语言变化更新 (无明确列出)主要 API变化引入 网络（Network）： Unix-Domain Socket（JEP 380: Unix-Domain Socket Channels）Native： [孵化]替代 JNI Java API：JEP 389: Foreign Linker API(Incubator), [孵化]外部内存访问 API（JEP 393: Foreign-Memory Access API(Third Incubator)）主要 API变化更新 (无明确列出)主要 JVM变化引入 源码（SourceCode）： 激活 C++ 14特性（JEP 347: Enable C++14 Language Features）, 迁移到 Git上（JEP 357: Migrate from Mercurial to Git）, Alpine Linux实现（JEP 386: Alpine Linux Port）, Windows/AArch64实现（JEP 388: Windows/AArch64 Port）主要 JVM变化更新 垃圾回收（Garbage Collection） ZGC 并发线程栈处理（JEP 376: ZGC: Concurrent Thread-Stack Processing）性能提升（Performance）工具（Tools） jpackage容器打包工具（JEP 392: Packaging Tool）Java 17（LTS）主要语言变化引入 Sealed类正式引入（JEP 409: Sealed Classes）浮点数：浮点数默认 strictfp （JEP 306: Restore Always-Strict Floating-Point Semantics）主要语言变化更新 (无明确列出)主要 API变化引入 模块化（Modular）：JDK内部 API强封装（JEP 403: Strongly Encapsulate JDK Internals）[预览] Switch语句增强模式匹配（JEP 406: Pattern Matching for switch(Preview)）[孵化]向量 API（JEP 414: Vector API(Second Incubator)）[孵化]外部 Native函数和内存 API（JEP 412: Foreign Function&amp; Memory API(Incubator)）关联： JEP 424: Foreign Function&amp; Memory API(Preview), JEP 389: Foreign Linker API(Incubator), JEP 393: Foreign-Memory Access API(Third Incubator)工具（Utility）：Random增强（JEP 356: Enhanced Pseudo-Random Number Generators）主要 API变化更新 安全（Security）： 不推荐 SecurityManager，未来将移除（JEP 411: Deprecate the Security Manager for Removal）Remote Method Invocation（RMI）：移除 RMI Activation（JEP 407: Remove RMI Activation）对象序列化（Serialization）：上下文反序列化过滤器（JEP 415: Context-Specific Deserialization Filters）用户界面（UI）： Applet：不推荐使用，未来移除（JEP 398: Deprecate the Applet API for Removal）源码（SourceCode）： macOS/AArch64支持（JEP 391: macOS/AArch64 Port）工具（Tools）： 移除实验性 AOT和 JIT编译器（JEP 410: Remove the Experimental AOT and JIT Compiler），由 GraalVM替代用户界面（UI）： 新 macOS渲染引擎（JEP 382: New macOS Rendering Pipeline）主要 JVM变化引入 (无明确列出)主要 JVM变化更新 (无明确列出)第四部分：Java 18 - 21Java 18主要语言变化引入 [孵化]向量 API（JEP 417: Vector API(Third Incubator)）[预览] switch语句模式匹配（JEP 420: Pattern Matching for switch(Second Preview)）主要语言变化更新 (无明确列出)主要 API变化引入 [孵化]外部 Native函数和内存 API（JEP 419: Foreign Function&amp; Memory API(Second Incubator)）输入/输出（I/O）： UTF-8作为默认字符（JEP 400: UTF-8 by Default）反射（Reflection）： 基于 MethodHandlers重新实现核心反射API（JEP 416: Reimplement Core Reflection with Method Handles）网络（Network）： 简单 Web Server（JEP 408: Simple Web Server）, IP地址解析（JEP 418: Internet-Address Resolution SPI）主要 API变化更新 不推荐 Finalization，未来删除（JEP 421: Deprecate Finalization for Removal）工具（Tools） javadoc：API文档增加代码片段（JEP 413: Code Snippets in Java API Documentation） 主要 JVM变化引入(无明确列出) 主要 JVM变化更新(无明确列出) Java 19主要语言变化引入[预览] Record模式（JEP 405: Record Patterns(Preview)）[预览]虚拟线程（JEP 425: Virtual Threads(Preview)）[预览] switch语句模式匹配（JEP 427: Pattern Matching for switch(Third Preview)）[孵化]向量 API（JEP 426: Vector API(Fourth Incubator)） 主要语言变化更新(无明确列出) 主要 API变化引入[预览]外部 Native函数和内存 API（JEP 424: Foreign Function&amp; Memory API(Preview)）[孵化]结构化并发（JEP 428: Structured Concurrency(Incubator)） 主要 API变化更新源码（SourceCode）： Linux/RISC支持（JEP 422: Linux/RISC-V Port） 主要 JVM变化引入(无明确列出) 主要 JVM变化更新(无明确列出) Java 20主要语言变化引入[预览]虚拟线程（JEP 436: Virtual Threads(Second Preview)）[孵化]所用域值（JEP 429: Scoped Values(Incubator)）[预览] Record模式（JEP 432: Record Patterns(Second Preview)）[预览] switch语句模式匹配（JEP 433: Pattern Matching for switch(Fourth Preview)）[孵化]向量 API（JEP 438: Vector API(Fifth Incubator)） 主要语言变化更新(无明确列出) 主要 API变化引入[预览]外部 Native函数和内存 API（JEP 434: Foreign Function&amp; Memory API(Second Preview)）[孵化]结构化并发（JEP 437: Structured Concurrency(Second Incubator)） 主要 API变化更新(无明确列出) 主要 JVM变化引入(无明确列出) 主要 JVM变化更新(无明确列出) Java 21（LTS）主要语言变化引入虚拟线程（JEP 444: Virtual Threads）Record模式（JEP 440: Record Patterns）switch语句模式匹配（JEP 441: Pattern Matching for switch）[预览] String模板（JEP 430: String Templates(Preview)）[预览]未命名模式和变量（JEP 443: Unnamed Patterns and Variables(Preview)）[预览]未命名类和实例 main方法（JEP 445: Unnamed Classes and Instance Main Methods (Preview)）[预览]所用域值（JEP 446: Scoped Values(Preview)） 主要语言变化更新[孵化]向量 API（JEP 448: Vector API(Sixth Incubator)） 主要 API变化引入集合（Collections）：有序集合（JEP 431: Sequenced Collections）安全（Security）：Key封装 API（JEP 451: Prepare to Disallow the Dynamic Loading of Agents）[预览]外部 Native函数和内存 API（JEP 442: Foreign Function&amp; Memory API(Third Preview)）[预览]结构化并发（JEP 453: Structured Concurrency(Preview)） 主要 API变化更新(无明确列出) 主要 JVM变化引入垃圾回收（Garbage Collection） ZGC 分代 ZGC（JEP 439: Generational ZGC） 主要 JVM变化更新源码（SourceCode）： 移除 Windows 32位 x86实现（JEP 449: Deprecate the Windows 32-bit x86 Port for Removal）预备禁止动态 Agent加载（JEP 451: Prepare to Disallow the Dynamic Loading of Agents）非命名变量与模式（JEP 456: Unnamed Variables &amp; Patterns）[预览] super(…) 调用前声明语句（JEP 447: Statements before super(…)(Preview)）执行多文件源代码执行（JEP 458: Launch Multi-File Source-Code Programs）[预览]未命名类和实例 main方法（JEP 463: Implicitly Declared Classes and Instance Main Methods(Second Preview)）[预览] String模板（JEP 459: String Templates(Second Preview)）外部函数调用与内存 API（JEP 454: Foreign Function &amp; Memory API）[预览]类文件 API（JEP 457: Class-File API(Preview)）[预览] Stream收集操作符（JEP 461: Stream Gatherers(Preview)）[预览]结构化并发（JEP 462: Structured Concurrency(Second Preview)）[孵化]向量 API（JEP 460: Vector API(Seventh Incubator)）[预览]所用域值（JEP 464: Scoped Values(Second Preview)） 第五部分：Java 22 - 25Java 22主要语言变化引入[预览]原始类型在模式匹配、instanceOf与 switch（JEP 455: Primitive Types in Patterns, instanceof, and switch(Preview)）Markdown文档注释支持（JEP 467: Markdown Documentation Comments）[预览]模块导入声明（JEP 476: Module Import Declarations(Preview)）[预览]未命名类和实例 main方法（JEP 477: Implicitly Declared Classes and Instance Main Methods(Third Preview)）[预览]弹性构造器主体（JEP 482: Flexible Constructor Bodies(Second Preview)） 主要语言变化更新String模板 主要语言变化移除移除 java.lang.Thread.countStackFrames方法 主要 API变化引入(无明确列出) 主要 API变化更新(无明确列出) 主要 JVM变化引入垃圾回收（Garbage Collection） G1 区域固定（JEP 423: Region Pinning for G1） 主要 JVM变化更新(无明确列出) Java 23主要语言变化引入[预览]类文件 API（JEP 466: Class-File API(Second Preview)）[孵化]向量 API（JEP 469: Vector API(Eighth Incubator)）[预览] Stream收集操作符（JEP 473: Stream Gatherers(Second Preview)）[预览]结构化并发（JEP 480: Structured Concurrency(Third Preview)）[预览]所用域值（JEP 481: Scoped Values(Third Preview)） 主要语言变化更新(无明确列出) 主要语言变化移除移除性 Deprecated sun.misc.Unsafe内存存储方法（JEP 471: Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal） 主要 API变化引入(无明确列出) 主要 API变化更新(无明确列出) 主要 JVM变化引入垃圾回收（Garbage Collection） ZGC 默认激活分代 GC（JEP 474: ZGC: Generational Mode by Default）[实验]压缩对象头 （JEP 450: Compact Object Headers(Experimental)）Project Lilliput 准备限制 JNI的使用（JEP 472: Prepare to Restrict the Use of JNI）[预览]密钥派生函数 API（JEP 478: Key Derivation Function API(Preview)）AOT类加载与链接（JEP 483: Ahead-of-Time Class Loading &amp; Linking） 主要 JVM变化更新(无明确列出) Java 24主要语言变化引入PIN同步虚拟线程（JEP 491: Synchronize Virtual Threads without Pinning）链接无 JMODS运行时镜像（JEP 493: Linking Run-Time Images without JMODs）[预览]模块导入声明（JEP 494: Module Import Declarations(Second Preview)）[预览]未命名类和实例 main方法（JEP 495: Simple Source Files and Instance Main Methods (Fourth Preview)）JEP 496: Quantum-Resistant Module-Lattice-Based Key Encapsulation MechanismJEP 497: Quantum-Resistant Module-Lattice-Based Digital Signature Algorithm 主要语言变化更新[预览]原始类型在模式 matching、instanceOf与 switch（JEP 488: Primitive Types in Patterns, instanceof, and switch(Second Preview)）[预览]弹性构造器主体（JEP 492: Flexible Constructor Bodies(Third Preview)） 主要语言变化移除移除 Windows 32位 x86架构（JEP 479: Remove the Windows 32-bit x86 Port）移除 32位 x86架构（JEP 501: Deprecate the 32-bit x86 Port for Removal） 主要 API变化引入类文件 API（JEP 484: Class-File API）Stream收集操作符（JEP 485: Stream Gatherers）永久失效 SecurityManager（JEP 486: Permanently Disable the Security Manager）[预览]所用域值（JEP 487: Scoped Values(Fourth Preview)）[孵化]向量 API（JEP 489: Vector API(Ninth Incubator)）[预览]结构化并发（JEP 499: Structured Concurrency(Fourth Preview)）警告 sun.misc.Unsafe内存存储方法调用（JEP 498: Warn upon Use of Memory-Access Methods in sun.misc.Unsafe） 主要 API变化更新(无明确列出) 主要 JVM变化引入垃圾回收（Garbage Collection） Shenandoah GC [实验]分代 Generational GC（JEP 404: Generational Shenandoah(Experimental)）G1 GC 后期屏障扩充（JEP 475: Late Barrier Expansion for G1）移除非分代模式（JEP 490: ZGC: Remove the Non-Generational Mode） 主要 JVM变化更新(无明确列出) Java 25（LTS）","link":"/2025/11/30/java%E4%BB%8E1%E5%88%B025%E7%89%88%E6%9C%AC%E7%9A%84%E5%8F%98%E5%8C%96/"},{"title":"学习导航","text":"这里主要是学习导航 JavaAI各司大模型助理阿里通义千问腾讯元宝美团龙猫 学习文档Spring AI 官方文档Spring AI Alibaba阿里云百炼官方文档小马哥语雀文档Building effective agentsPrompt Engineering Guide","link":"/2025/11/29/navLink/"}],"tags":[{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"}],"pages":[]}